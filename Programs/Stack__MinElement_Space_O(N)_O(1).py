# -*- coding: utf-8 -*-
"""Stack__MinElement_Space_O(N)_O(1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FZon9fkspBRYCi77kl1pbUrnsZ8xIH7-

You are given N elements and your task is to Implement a Stack in which you can get minimum element in O(1) time.

Example 1:

Input:

push(2)

push(3)

pop()

getMin()

push(1)

getMin()

Output: 3 2 1

Explanation: In the first test case for
query 

push(2)  the stack will be {2}

push(3)  the stack will be {2 3}

pop()    poped element will be 3 the
         stack will be {2}

getMin() min element will be 2 

push(1)  the stack will be {2 1}

getMin() min element will be 1

Your Task:

You are required to complete the three methods push() which take one argument an integer 'x' to be pushed into the stack, pop() which returns a integer poped out from the stack and getMin() which returns the min element from the stack. (-1 will be returned if for pop() and getMin() the stack is empty.)

Expected Time Complexity : O(1) for all the 3 methods.

Expected Auixilliary Space : O(1) for all the 3 methods.
"""

class Stack:
  def __init__(self,n):
    self.stack=[]
    self.size=n

  def push(self,element):
    if (len(self.stack) == self.size):
      printf("STACK IS FULL")
    else:
      self.stack.append(element)

  def pop(self):
    if (len(self.stack) == 0):  #or self.stack==[]
      printf("STACK IS EMPTY")
    else:
      return self.stack.pop()

  def stack_size(self):
    size=len(self.stack)
    return size

  def isempty(self):
    x=self.size
    if x==0:
      print("Stack is empty")
      return 1
    else:
      print("Not empty")
      return 0

  def top(self):
    if len(self.stack)>0:
      #print (len(self.stack))
      return self.stack[len(self.stack)-1]
    else:
      return -1

#O(n)
def push_ele(s,ss,a):
  s.push(a)
  if (ss.stack_size()==0 or ss.top()>=a):
    ss.push(a)
def pop_ele(s,ss):
  if s.size()==0:
    return -1
  ans=s.top
  s.pop()
  if s.top==ans:
    ss.pop()
  return ans
def get_min(s,ss):
  if ss.stack_size()==0:
    return -1
  return ss.top()

s=Stack(10)
ss=Stack(10)
push_ele(s,ss,18)
push_ele(s,ss,19)
push_ele(s,ss,29)
push_ele(s,ss,15)
push_ele(s,ss,16)
get_min(s,ss)

#O(1)
min=-1

def get_min_O1(s):
  global min
  if s.stack_size()==0:
    return -1
  return min
def push_ele_O1(s,a):
  global min
  if s.stack_size()==0:
    s.push(a)
    min=a
  elif a>=min:
    s.push(a)
  elif a<min:
    s.push(2*a-min)
    min=a
  return min
def pop_ele_O1(s):
  global min
  if s.stack_size()==0:
    return -1
  elif s.top()>=min:
    s.pop()
  elif s.top()<min:
    min=2*min-s.top()
    s.pop()
def top_ele_O1(s):
  global min
  if s.stack_size()==0:
    return -1
  elif s.top()>=min:
    return s.top()
  elif s.top()<min:
    return min

s=Stack(10)
push_ele_O1(s,18)
push_ele_O1(s,19)
push_ele_O1(s,29)
push_ele_O1(s,15)
push_ele_O1(s,16)
get_min_O1(s)
print(min)
pop_ele_O1(s)
pop_ele_O1(s)
pop_ele_O1(s)
print(min)