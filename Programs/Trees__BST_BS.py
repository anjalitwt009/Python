# -*- coding: utf-8 -*-
"""BST_BS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wvzukj9O-LKaBsnHm0aViCJJVDWRtg1N
"""

def BS(A,ele,i,j):
  r=i+j//2
  flag= False 
  if len(A)>1 and i<=r<=j:
    if ele>A[r]:
      BS(A,ele,r,j)
    elif (ele<A[r]):
      BS(A,ele,i,r)
    else:
      flag= True
      print(flag)
      return flag
  else:
    print(flag)
    return flag

A=[1,2,3,4,5]
BS(A,8,0,4)

class Node:
  def __init__(self,data):
    self.data=data
    self.left=None
    self.right=None

class BST:
  def __init__(self):
    self.head=None
  def insert(self,ele,new):
    if self.head==None:
      self.head=new_data
    else:
      if ele>new.data and new.right!=None :
        new=new.right
        self.insert(ele,new)
      elif ele>new.data and new.right==None :
        new_data=Node(ele)
        new.right=new_data
      elif ele<new.data and new.left!=None :
        new=new.left
        self.insert(ele,new)
      elif ele<new.data and new.left==None :
        new_data=Node(ele)
        new.left=new_data
  def inorder_traverse(self,new):
    print("--------TRAVERSING---------")
    if new: 
      # First recur on left child 
      self.inorder_traverse(new.left) 
      # then print the data of node 
      print(new.data), 
      # now recur on right child 
      self.inorder_traverse(new.right)

n1=Node(1)

tree=BST()
tree.head=n1

tree.insert(5,tree.head)
tree.insert(18,tree.head)
tree.insert(2,tree.head)
tree.insert(6,tree.head)
tree.insert(9,tree.head)

tree.inorder_traverse(tree.head)