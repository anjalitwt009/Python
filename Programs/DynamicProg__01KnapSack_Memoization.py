# -*- coding: utf-8 -*-
"""DynamicProg__01KnapSack_Memoization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VIZMVz61352OQ9m-o7JfglqjJGJ9rmhY

Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In other words, given two integer arrays val[0..n-1] and wt[0..n-1] which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You cannot break an item, either pick the complete item or donâ€™t pick it (0-1 property).

INPUT:

val = [60, 100, 120] 

wt = [10, 20, 30] 

W = 50

n = len(val) 

OUTPUT:

220
"""

def knap_01(wt,val,W,n):
  global t
  if n==0 or W==0:
    return 0
  if t[n][W]!=-1:
    return t[n][W]
  if wt[n-1]<=W:
    t[n][W]=max((val[n-1]+knap_01(wt,val,W-wt[n-1],n-1)),knap_01(wt,val,W,n-1))
    return t[n][W]
  else:
    knap_01(wt,val,W,n-1)
    return t[n][W]

val = [60, 100, 120] 
wt = [10, 20, 30] 
W = 50
n = len(val)
t=[[-1 for i in range(W + 1)] for j in range(n + 1)] 
ans=knap_01(wt,val,W,n)
ans