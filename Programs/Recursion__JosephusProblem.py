# -*- coding: utf-8 -*-
"""Recursion__JosephusProblem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GUqMz-Y3m3yec3cKmyVN--flXIR5SHZK

Josephus Problem.

Given total person n and a number k, k-1 person are skipped and kth person is killed in a circle in a fixed direction. Choose the safe position in a circle.

Example 1:

*INPUT:*

n=3

k=2

*OUTPUT:*

3

Example 2:

*INPUT:*

n=5

k=3

*OUTPUT:*

4

STEPS:

(7,3)

1. create an array of n elements:

A:  1,2,3,4,5,6,7   

index: 0,1,2,3,4,5,6

2. sword in at position one: index '0' and ever third person is killed : index '2' which is 'k-1'.

3. pop out A[2]=3 and sword goes to A[3]=4.

A:  1,2,4,5,6,7   

index: 0,1,2,3,4,5

4. Rearranged: Sword at A[2]=4.

5. pop out A[4]=6 and sword goes to A[5]=7.

A:  1,2,4,5,7   

index: 0,1,2,3,4

6.  Repeat till len(A)==1.
"""

def josephus(N,k):
  if N==1:
    return 1
  else:
    return (josephus(N - 1, k) + k-1) % N + 1

def jose_alt(N,k):
  #form an array of N elements
  A=[]
  #According to zero indexing k--
  k=k-1
  for i in range(1,N+1):
    A.append(i)
  print("A={}".format(A))
  find_one(A,k,0,-1)

def find_one(A,k,index,ans):
  #index is the start of count from where the kth person has to be killed
  if len(A)==1:
    ans=A[0]
    print("Ans:{}".format(A))
    return
  else:
    #to kill the kth element from the start index: index+k
    #if len(A)<k: we need to find the mod to return back to the starting index
    # Example: A=[1,2,3] and wrt indexing:k=k-1=3 ; index_old=0,kill A[2]=3
    # step 1: A=[1,2] ; index_new= index_old+k= 2 ; but we dont have index 3 and hence we need a mod value wrt len(A); 
              # index_new=2%len(A)=0
    # step 2: A=[2]: Ans
    index=(index+k) % len(A)
    print("Index={}".format(index))
    A.pop(index)
    print("A={}".format(A))
    find_one(A,k,index,ans)

N=int(input("Enter N:"))
k=int(input("Enter k:"))
x=josephus(N,k)
print(x)

jose_alt(N,k)