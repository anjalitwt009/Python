# -*- coding: utf-8 -*-
"""Recursion__Sort_Stack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17S6dTKrgtJhdmV3AxJITzRXkvZWjvlc7

Given a stack, the task is to sort it such that the top of the stack has the greatest element.

Example 1:

Input:

Stack: 3 2 1

Output: 3 2 1

Example 2:

Input:

Stack: 11 2 32 3 41

Output: 41 32 11 3 2

Your Task: 

You don't have to read input or print anything. Your task is to complete the function sort() which sorts the elements present in the given stack. (The sorted stack is printed by the driver's code by popping the elements of the stack.)

Expected Time Complexity : O(N*N)

Expected Auixilliary Space : O(N) recursive.

Constraints:

1<=N<=100
"""

class Stack:
  def __init__(self,n):
    self.stack=[]
    self.size=n

  def push(self,element):
    if (len(self.stack) == self.size):
      printf("STACK IS FULL")
    else:
      self.stack.append(element)

  def pop(self):
    if (len(self.stack) == 0):  #or self.stack==[]
      printf("STACK IS EMPTY")
    else:
      return self.stack.pop()
      
  def size_stack(self):
    size=len(self.stack)
    return size

  def isempty(self):
    x=self.size
    if x==0:
      print("Stack is empty")
      return 1
    else:
      print("Not empty")
      return 0

  def top(self):
    if len(self.stack)>0:
      #print (len(self.stack))
      return self.stack[len(self.stack)-1]
    else:
      return -1

def sort(A):
  if A.size_stack()==1:
    return
  temp=A.top()
  A.pop()
  #print(A)
  sort(A)
  return insert(A,temp)

def insert(A,temp):
  if A.size_stack()==0 or temp>=A.top():
    return A.push(temp)
  else:
    val=A.top()
    A.pop()
    #print(A,temp)
    insert(A,temp)
    return A.push(val)

A=Stack(4)
A.push(5)
A.push(1)
A.push(0)
A.push(2)
sort(A)
A

print(A.top())
A.pop()
print(A.top())
A.pop()
print(A.top())
A.pop()
print(A.top())