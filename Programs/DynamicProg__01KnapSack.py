# -*- coding: utf-8 -*-
"""DynamicProg__01KnapSack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1833zXal45-8W6x0EZe8F56SNOhFDy-rq

Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In other words, given two integer arrays val[0..n-1] and wt[0..n-1] which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You cannot break an item, either pick the complete item or donâ€™t pick it (0-1 property).

INPUT:

val = [60, 100, 120] 

wt = [10, 20, 30] 

W = 50

n = len(val) 

OUTPUT:

220
"""

def knap_01(wt,val,W,n):
  t=[[0 for x in range(W + 1)] for x in range(n + 1)]
  for i in range(n+1):
    for j in range(W+1):
      if i==0 or j==0:
        t[i][j]=0
  for i in range(1,n+1):
    for j in range(1,W+1):
      if wt[i-1]<=j:
        t[i][j]=max((val[i-1]+
                     t[i-1][j-wt[i-1]]),
                     t[i-1][j])
      else:
        t[i][j]= t[i-1][j]
  print( t[n][W])

val = [60, 100, 120] 
wt = [10, 20, 30] 
W = 50
n = len(val)
t=[[-1 for i in range(W + 1)] for j in range(n + 1)] 
ans=knap_01(wt,val,W,n)
ans