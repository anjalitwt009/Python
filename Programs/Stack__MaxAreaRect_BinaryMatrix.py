# -*- coding: utf-8 -*-
"""Stack__MaxAreaRect_BinaryMatrix.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oFPJs8NMWHSkCYdXBe0HTHesZhjFX1u-

Given a binary matrix. Find the maximum area of a rectangle formed only of 1s in the given matrix.

Example 1:

Input:

n = 4, m = 4

M[][] = {{0 1 1 0},
         {1 1 1 1},
         {1 1 1 1},
         {1 1 0 0}}

Output: 8

Explanation: For the above test case the
matrix will look like

0 1 1 0

1 1 1 1

1 1 1 1

1 1 0 0

the max size rectangle is 

1 1 1 1

1 1 1 1

and area is 4 *2 = 8.

Your Task: 

Your task is to complete the function maxArea which returns the maximum size rectangle area in a binary-sub-matrix with all 1â€™s. The function takes 3 arguments the first argument is the Matrix M[ ] [ ] and the next two are two integers n and m which denotes the size of the matrix M. 

Expected Time Complexity : O(n*m)

Expected Auixiliary Space : O(m)

Constraints:

1<=n,m<=1000

0<=M[][]<=1
"""

class Stack:
  def __init__(self,n):
    self.stack=[]
    self.index=[]
    self.size=n

  def push(self,element,index):
    if (len(self.stack) == self.size):
      print("STACK IS FULL")
    else:
      self.stack.append(element)
      self.index.append(index)

  def pop(self):
    if (len(self.stack) == 0):  #or self.stack==[]
      #print("STACK IS EMPTY")
      return -1
    else:
      self.stack.pop()
      self.index.pop()
      return 0
  
  def size_stack(self):
    size=len(self.stack)
    return size

  def isempty(self):
    x=self.size
    if x==0:
      print("Stack is empty")
      return 1
    else:
      print("Not empty")
      return 0

  def top(self):
    if len(self.stack)>0:
      #print (len(self.stack))
      A=[]
      A.append(self.stack[len(self.stack)-1]) 
      A.append(self.index[len(self.stack)-1])
      return A
    else:
      A=[]
      A.append(-1)
      A.append(-1)
      return A

def NSL_index(A):
  out_arr=[]
  out_index=[]
  s=Stack(len(A))
  for i in range(len(A)):
    if s.size_stack()==0:
      out_arr.append(-1)
      out_index.append(-1)
    elif s.size_stack()>0 and s.top()[0]<A[i]:
      out_arr.append(s.top()[0])
      out_index.append(i-1)
    elif s.size_stack()>0 and s.top()[0]>=A[i]:
      while (s.size_stack()>0):
        if (s.top()[0]>=A[i]):
          s.pop()
          #print(s.size_stack())
        else:
          break
      if s.size_stack()==0:
        out_arr.append(-1)
      else:
        out_arr.append(s.top()[0])
      out_index.append(s.top()[1])
    s.push(A[i],i)
  #out_arr.reverse()
  #print(out_arr)
  print(out_index)
  return out_index

def NSR_index(A):
  out_arr=[]
  out_index=[]
  s=Stack(len(A))
  for i in range(len(A)-1,-1,-1):
    if s.size_stack()==0:
      out_arr.append(0)
      out_index.append(len(A))
    elif s.size_stack()>0 and s.top()[0]<A[i]:
      out_arr.append(s.top()[0])
      out_index.append(i+1)
    elif s.size_stack()>0 and s.top()[0]>=A[i]:
      while (s.size_stack()>0):
        if (s.top()[0]>=A[i]):
          s.pop()
          #print(s.size_stack())
        else:
          break
      if s.size_stack()==0:
        out_arr.append(0)
        out_index.append(len(A))
      else:
        out_arr.append(s.top()[0])
        out_index.append(s.top()[1])
    s.push(A[i],i)
  out_index.reverse()
  #print(out_arr)
  print(out_index)
  return out_index

def max_ar(A):
  Right=NSR_index(A)
  Left=NSL_index(A)
  width=[]
  max=0
  for i in range(len(A)):
    width.append(Right[i]-Left[i]-1)
    ar=(Right[i]-Left[i]-1)*A[i]
    if ar>max:
      max=ar
  print(width)
  print(max)
  return max

#test code
A=[[0,1,1,0],[1,1,1,1],[1,1,1,1],[1,1,0,0]]
print(type(A[0]))
print(A[0])
max=max_ar(A[0])
v=[0]*4
for i in range(1,4):
  for j in range(4):
    if A[i][j]!=0:
      v[j]=v[j]+ A[i][j]
    else:
      v[j]=0
  print(v)
  x=max_ar(v)
  if x>max:
    max=x
print(max)

N=int(input("No. of rows: "))
M=int(input("No. of cols: "))
mat=[]
for i in range(N):
  A=[]
  for j in range(M):
    A.append(int(input()))
  mat.append(A)

max=max_ar(mat[0])
v=[0]*M
for i in range(1,N):
  for j in range(M):
    if mat[i][j]!=0:
      v[j]=v[j]+ mat[i][j]
    else:
      v[j]=0
  print(v)
  x=max_ar(v)
  if x>max:
    max=x
print(max)