# -*- coding: utf-8 -*-
"""Sorting__MergeSort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SVDmHMlHnu9be6VOShC1iO_hwWwFMRSJ

***MERGE SORT:***

1.   Divide the array into two halves.(A[l,mid],A[mid,r])
2.   Seperately Sort left and right half
3.   Combine the two sorted halves to get the full array sorted.

*MERGING:*

1.   Given two sorted lists A,B combine into sorted list C.


*   Compare the first elements of A,B.
*   Move the minimum to C.
*   If A is empty move B to C.
*   If B is empty move A to C.
*   Repeat until all the elements in A,B are over.

2.   Merging A,B.


***TIME COMPLEXITY(MERGE)=O(max(m,n))=O(n)  (nearly)***

***TIME COMPLEXITY(MERGE SORT)= O(nlog n)***

*T(n)=2T(n/2)+n  (2 halves + Merge)*

***SPACE COMPLEXITY=O(n)***
"""

def merge(A,B):
  C=[]
  m,n=0,0
  if A:
    m=len(A)
  if B:
    n=len(B)
  #(C,m,n)=([],len(A),len(B))
  i=0
  j=0
  #(i,j)=(0,0)

  while (i+j<m+n):
    #Case1: A is empty, append B[j] to C, increment j
    if (i==m):
      C.append(B[j])
      j=j+1

    #Case2: B is empty, append A[i] to C, increment i
    elif (j==n):
      C.append(A[i])
      i=i+1

    #Case3: B[j]<A[i], append B[j], increment j
    elif (B[j]<=A[i]):
      C.append(B[j])
      j=j+1

    #Case4: B[j]>A[i], append A[i], increment i
    elif (B[j]>A[i]):
      C.append(A[i])
      i=i+1

  return(C)

def merge_sort(A,l,r):
  if r-l<=1:
    return (A[l:r])
  
  mid=(l+r)//2
  Left = merge_sort(A,l,mid)
  Right = merge_sort(A,mid,r)
  return (merge(Left,Right))

import sys
sys.setrecursionlimit(5000)
A=[1,4]
B=[2,3]
merge(A,B)
A=[1,2,5,3,4,6,7]
B=merge_sort(A,0,6)
print(B)

#Alternatively
def merge(left, right):
    """Merge sort merging function."""

    left_index, right_index = 0, 0
    result = []
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            result.append(left[left_index])
            left_index += 1
        else:
            result.append(right[right_index])
            right_index += 1

    result += left[left_index:]
    result += right[right_index:]
    return result


def merge_sort(array):
    """Merge sort algorithm implementation."""

    if len(array) <= 1:  # base case
        return array

    # divide array in half and merge sort recursively
    half = len(array) // 2
    left = merge_sort(array[:half])
    right = merge_sort(array[half:])

    return merge(left, right)

A=[1,2,5,3,4,6]
B=merge_sort(A)